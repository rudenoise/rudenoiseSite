<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>
OCaml Diary, Part 4B
        </title>
        <style type="text/css">
            @font-face {
                    font-family: 'ocramedium';
                    src: url('ocr-a.eot');
                    src: url('ocr-a.eot?#iefix') format('embedded-opentype'),
                         url('ocr-a.woff') format('woff'),
                         url('ocr-a.ttf') format('truetype'),
                         url('ocr-a.svg#ocramedium') format('svg');
                    font-weight: normal;
                    font-style: normal;
            }
            body {
                margin: 1em auto;
                padding-left: .5em;
                padding-right: 1.5em;
                max-width: 640px;
                font-size: 135%;
                line-height: 1.5em;
                background: #222;
                color: #CCC;
                font-family: ocramedium, ocraextended, monospace;
                background-image: url("/bg.png");
                background-repeat: repeat;
            }
            article {
                text-align: justify;
            }
            blockquote {
                font-size: 0.9em;
                font-style: oblique;
            }
            .caption {
                font-size: 0.7em;
                font-style: italic;
            }
            img {
                width: 100%;
                height: auto;
                max-width: 640px;
            }
            @media only screen and (max-width: 400px) {
                body {font-size: 100%;}
            }
            a {
                color: orange;
                text-decoration: none;
                border-bottom: 1px solid;
            }
            sub>em>a { border-bottom: none; }
            h1 { line-height: 1em;}
            form {border: none}
            input { font-family: ocramedium, ocraextended, monospace; border: none; }
            .small { font-size: 65%;}
            pre {
                overflow-x: scroll; 
                background: #444;
                color: #FFF;
                text-align: left;
            }
            .ocaml .fl {
                color: yellow;
            }
            .ocaml .kw {
                color: #ffb380;
            }
            .ocaml .co {
                color: #ccc;
            }
        </style>
        <link rel="alternate" type="application/rss+xml" title="Rudenoise's Feed" href="http://rudenoise.uk/feed.rss">
        <link rel="alternate" type="application/rss+xml" title="Rudenoise's OCaml Feed" href="http://rudenoise.uk/ocaml.rss">
        <meta name="viewport" content="width=device-width,initial-scale=1">

    </head>
    <body>
        <article>
            <header>
                <h1>
OCaml Diary, Part 4B
                </h1>
                <p class="small">Published:
                    <time>
2016-02-24
                    </time>
                </p>
            </header>
<p>Having set up a MirageOS development environment <sub>[<em><a href="#ref1">1</a></em>]</sub> I continued improving my OCaml.</p>
<p>When experimenting with new languages in the past, I've made the same small CLI application. A program that walks through the contents of a directory, stores the paths of any files contained within, then does the same for any sub-directroies, recursively. These paths can then be printed to the console directly, or filtered then printed. So far I've done this task using NodeJS, Go and Gambit Scheme. I usually call it <em>inPath</em>.</p>
<p>The aim is to test my ability to build something small, self contained and useful, from scratch. Doing so ensures that I know the tools used to build and debug the app, and where to find supporting information.</p>
<h2 id="the-development-experience">The Development Experience</h2>
<p>The development cycle went something like this:</p>
<ul>
<li>Edit inPath.ml in vim.</li>
<li>Save and see if <em>Merlin</em> has picked up any problems.</li>
<li>Run <em>MerlinErrorCheck</em> correct as necessary.</li>
<li>Run <em>corebuild inPath.byte</em> for fast compilation to byte-code.</li>
<li>Every few successful builds compile a native executable with <em>corebuild inPath.native</em>.</li>
</ul>
<p>Getting the environment set up involves a few steps but afterwards the cycle was smooth and efficient. It may only be a tiny project but I was impressed by the support the tools provide. They may not be as simple as those provided by Go (there are a lot of ways to compile an OCaml program) but the compiler is highly configurable while still usable for a novice.</p>
<p>The program used various modules from <em>Core.Std</em>, an equivalent to a standard-library (OCaml keeps itself small allowing the user to customise as required). Building CLI apps is well supported via the <em>Command</em> module. Help text, input parsing and flags have useful APIs, getting the basics working was equivalent the effort needed on other ecosystems.</p>
<p>Switching between &quot;pure functional&quot; (for internal data structures and recursion) and imperative (communicating with the environment outside) APIs was useful. Having distinct types and modules for each helps to define the boundaries.</p>
<p>The general impression I've formed is that OCaml has a reasonably high barrier to entry. There are many ways to use the tools and language and this can feel daunting. Conversely, the many combinations/configurations available make it possible to express very clear programs that are tailored and specific to their problem-space. The type system and language design also make solutions less ambiguous. I'm less likely to mistake one implementation for another and should I, the compiler is likely to know about it.</p>
<p>Iterating the design and implementation of OCaml programs differs from other ecosystems, that I've used. Getting a basic/prototype implementation was quick. Refactoring could then take a number of paths depending on how I wished to extend the functionality. Moving data processing to purely functional data-structures and APIs, for example. Or bundling areas of the code into modules, using their own types and interfaces, to aid separation of concerns, documentation of intent and reuse. Various constructs for building flows and passing data between functions could be chosen. I didn't get as far as using the native profiling tools or compiler configurations.</p>
<p>This could be seen as unnecessary complexity, especially when compared with Go's approach. But getting something basic working can be quick, after which point there are a lot of options available for improvement. The results may not be generic but they will be descriptive. It's a different approach and one I enjoyed.</p>
<h2 id="the-results">The Results</h2>
<p>A few hours mucking about and I had the basics working. It seems the language is seeping into my brain at a good rate. I can build basic software.</p>
<h2 id="links">Links</h2>
<ul>
<li><a id="ref1"></a> <a href="/ocaml-mirageos-diary-4a.html">OCaml/MirageOS Diary, Part 4A</a></li>
<li><a id="ref2"></a> <a href=""></a></li>
<li><a id="ref3"></a> <a href=""></a></li>
<li><a id="ref4"></a> <a href=""></a></li>
<li><a id="ref5"></a> <a href=""></a></li>
<li><a id="ref6"></a> <a href=""></a></li>
<li><a id="ref7"></a> <a href=""></a></li>
<li><a id="ref8"></a> <a href=""></a></li>
<li><a id="ref9"></a> <a href=""></a></li>
<li><a id="ref10"></a> <a href=""></a></li>
<li><a id="ref11"></a> <a href=""></a></li>
<li><a id="ref12"></a> <a href=""></a></li>
<li><a id="ref13"></a> <a href=""></a></li>
</ul>
            <footer>
                <p class="small">If you want to be informed when more of this stuff is written you can <a href="/subscribe.html">subscribe</a> or why not look at <a href="/">Rudenoise's home page</a>?</p>
            </footer>            
        </article>
    </body>
</html>
