# OCaml Diary, Week 3

Whilst continuing to work through _Real World Ocaml_, I did some
research into projects that make use of it and found a project
that really caught my interest. MirageOS <sub>[_[1](#ref1)_]</sub>.

I've been working on DevOps projects for clients for a while and
have made use of Docker as part of development environments for the
teams I've worked in and as a deployable wrapper around
applications going into "_the cloud_". As a developer Docker, has
been useful in creating portable, reproducible environments and as
the platform progresses I've been looking at reducing the number of
moving parts in the stack. In a NodeJS stack, that is a lot of
moving parts (Operating System, NodeJS, NPM packages - a lot of NPM
packages - and sitting on top the application's code, AKA the value).

This is a lot of stuff to use when the application itself can be
pretty small, especially in the case of micro-services. There is a
lot of coupling and dependency in these stack and, once bundled,
the combined size is significant. To reconstruct the constituent
parts takes time, more parts more time. This slows down deploy
times and becomes brittle.

Another factor to consider is security. A web-application's
vulnerabilities are highly exposed so developers need to be mindful
about the attack-surfaces they may introduce. That's a difficult
task when reasoning about application logic, alone. For the jobbing
full-stack, DevOps engineer it would be valuable be able to know
about all the attack-surfaces and monitor/manage them. This is a
lot of work when taking into account the stack beneath the app.
What does the Linux distribution and version contain? What
applications have been added via the package manager? If this is a
node app what do all the NPM package dependencies do? That is a lot
of questions to answer and this is a mutable stack, updates need to
be made and the system's variety shifting and growing.

## Reducing the Stack

One improvement over big stacks like those often used in NodeJS is
to reduce the size of the docker-container and deploy a self
contained binary on top. For example: A GoLang app inside
micro-container is a decent combination and well worth considering.

It turns out that the refining process can be taken further. One
approach is the use of micro-kernels, MirageOS, for example.

## Links

* <a id="ref1"></a> [Mirage OS](https://mirage.io/)
* <a id="ref2"></a> []()
* <a id="ref3"></a> []()
* <a id="ref4"></a> []()
* <a id="ref5"></a> []()
* <a id="ref6"></a> []()
* <a id="ref7"></a> []()
* <a id="ref8"></a> []()
* <a id="ref9"></a> []()
* <a id="ref10"></a> []()
