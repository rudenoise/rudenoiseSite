# OCaml Diary, Week One

I decided to start learning a new programming language, selecting
candidates based on pragmatic logic: likelihood of paid work,
tooling, community, problem space fit, etc...

Based on this Go was a leading contender. I'd done a bit before and
quite enjoyed its cool-because-it's-not-cool styling. It's the kind
of language and tool-chain that can be recommended without much
risk and it's got plenty of well thought out advantages over other
programming ecosystems. It even has a big corporation sponsoring it
as an open source project.

So I bought "The Go Programming Language" and read the introduction.
It was well written and inviting. Scanning the rest of the book,
previous experiences came back and the memories were positive.

A week later and the book-mark was still at chapter 1.

Another week later, on a whim, I'd installed some of the OCaml tool
chain. The online materials were not as plentiful or well
constructed as Go's but I was intrigued. I started "Real World OCam"
online, then bought the physical book. I even did a boast on
Twitter. Now I've written this.

OCaml is drawing me in because I like the role it enables me to play.
It's seen as esoteric and difficult without the obviousness of
Haskell. It's used on the fringes. The barrier to entry is
reassuringly high. Advocates talk about its speed and ability to
encapsulate certain problem sets more succinctly. This is all
reassuring but not the source of its appeal to me. It feels good to
be on the fringes of the computing industry without any real risk.

I'm here because of an aesthetic choice. Despite all the scientific
allusion of the computing industry, and the use of the words
computer science, I don't think much about the comparisons and
discussions on relative merits (despite reading them). It comes
down to gut feel and intuition.

That isn't to say that I see programming as an art or means of
finding creative truth. For me, it's a process of pleasing shallow
clarity. What you get is what you type, if it works it works and I
get to play the role of a programmer. It's an escape from the deep
problems into the ones that can actually be solved. I want to make
things that give the impression of progression and make me feel
clever (because the problems are hard but not too hard).
